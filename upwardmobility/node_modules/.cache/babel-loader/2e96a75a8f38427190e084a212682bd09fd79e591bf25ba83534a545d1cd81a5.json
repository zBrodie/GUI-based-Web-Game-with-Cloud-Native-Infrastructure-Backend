{"ast":null,"code":"import { applyMiddleware, createStore } from 'redux';\nimport { e as error, j as UNDO, R as REDO, M as MAKE_MOVE } from './turn-order-8cc4909b.js';\nimport { P as ProcessGameConfig, C as CreateGameReducer, T as TransientHandlingMiddleware, I as IsLongFormMove } from './reducer-24ea3e4c.js';\nimport { i as isSynchronous, c as createMatch } from './util-991e76bb.js';\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n/**\r\n * Filter match data to get a player metadata object with credentials stripped.\r\n */\nconst filterMatchData = matchData => Object.values(matchData.players).map(player => {\n  const {\n    credentials,\n    ...filteredData\n  } = player;\n  return filteredData;\n});\n/**\r\n * Remove player credentials from action payload\r\n */\nconst stripCredentialsFromAction = action => {\n  const {\n    credentials,\n    ...payload\n  } = action.payload;\n  return {\n    ...action,\n    payload\n  };\n};\n/**\r\n * Master\r\n *\r\n * Class that runs the game and maintains the authoritative state.\r\n * It uses the transportAPI to communicate with clients and the\r\n * storageAPI to communicate with the database.\r\n */\nclass Master {\n  constructor(game, storageAPI, transportAPI, auth) {\n    this.game = ProcessGameConfig(game);\n    this.storageAPI = storageAPI;\n    this.transportAPI = transportAPI;\n    this.subscribeCallback = () => {};\n    this.auth = auth;\n  }\n  subscribe(fn) {\n    this.subscribeCallback = fn;\n  }\n  /**\r\n   * Called on each move / event made by the client.\r\n   * Computes the new value of the game state and returns it\r\n   * along with a deltalog.\r\n   */\n  async onUpdate(credAction, stateID, matchID, playerID) {\n    if (!credAction || !credAction.payload) {\n      return {\n        error: 'missing action or action payload'\n      };\n    }\n    let metadata;\n    if (isSynchronous(this.storageAPI)) {\n      ({\n        metadata\n      } = this.storageAPI.fetch(matchID, {\n        metadata: true\n      }));\n    } else {\n      ({\n        metadata\n      } = await this.storageAPI.fetch(matchID, {\n        metadata: true\n      }));\n    }\n    if (this.auth) {\n      const isAuthentic = await this.auth.authenticateCredentials({\n        playerID,\n        credentials: credAction.payload.credentials,\n        metadata\n      });\n      if (!isAuthentic) {\n        return {\n          error: 'unauthorized action'\n        };\n      }\n    }\n    const action = stripCredentialsFromAction(credAction);\n    const key = matchID;\n    let state;\n    if (isSynchronous(this.storageAPI)) {\n      ({\n        state\n      } = this.storageAPI.fetch(key, {\n        state: true\n      }));\n    } else {\n      ({\n        state\n      } = await this.storageAPI.fetch(key, {\n        state: true\n      }));\n    }\n    if (state === undefined) {\n      error(`game not found, matchID=[${key}]`);\n      return {\n        error: 'game not found'\n      };\n    }\n    if (state.ctx.gameover !== undefined) {\n      error(`game over - matchID=[${key}] - playerID=[${playerID}]` + ` - action[${action.payload.type}]`);\n      return;\n    }\n    const reducer = CreateGameReducer({\n      game: this.game\n    });\n    const middleware = applyMiddleware(TransientHandlingMiddleware);\n    const store = createStore(reducer, state, middleware);\n    // Only allow UNDO / REDO if there is exactly one player\n    // that can make moves right now and the person doing the\n    // action is that player.\n    if (action.type == UNDO || action.type == REDO) {\n      const hasActivePlayers = state.ctx.activePlayers !== null;\n      const isCurrentPlayer = state.ctx.currentPlayer === playerID;\n      if (\n      // If activePlayers is empty, non-current players can’t undo.\n      !hasActivePlayers && !isCurrentPlayer ||\n      // If player is not active or multiple players are active, can’t undo.\n      hasActivePlayers && (state.ctx.activePlayers[playerID] === undefined || Object.keys(state.ctx.activePlayers).length > 1)) {\n        error(`playerID=[${playerID}] cannot undo / redo right now`);\n        return;\n      }\n    }\n    // Check whether the player is active.\n    if (!this.game.flow.isPlayerActive(state.G, state.ctx, playerID)) {\n      error(`player not active - playerID=[${playerID}]` + ` - action[${action.payload.type}]`);\n      return;\n    }\n    // Get move for further checks\n    const move = action.type == MAKE_MOVE ? this.game.flow.getMove(state.ctx, action.payload.type, playerID) : null;\n    // Check whether the player is allowed to make the move.\n    if (action.type == MAKE_MOVE && !move) {\n      error(`move not processed - canPlayerMakeMove=false - playerID=[${playerID}]` + ` - action[${action.payload.type}]`);\n      return;\n    }\n    // Check if action's stateID is different than store's stateID\n    // and if move does not have ignoreStaleStateID truthy.\n    if (state._stateID !== stateID && !(move && IsLongFormMove(move) && move.ignoreStaleStateID)) {\n      error(`invalid stateID, was=[${stateID}], expected=[${state._stateID}]` + ` - playerID=[${playerID}] - action[${action.payload.type}]`);\n      return;\n    }\n    const prevState = store.getState();\n    // Update server's version of the store.\n    store.dispatch(action);\n    state = store.getState();\n    this.subscribeCallback({\n      state,\n      action,\n      matchID\n    });\n    if (this.game.deltaState) {\n      this.transportAPI.sendAll({\n        type: 'patch',\n        args: [matchID, stateID, prevState, state]\n      });\n    } else {\n      this.transportAPI.sendAll({\n        type: 'update',\n        args: [matchID, state]\n      });\n    }\n    const {\n      deltalog,\n      ...stateWithoutDeltalog\n    } = state;\n    let newMetadata;\n    if (metadata && (metadata.gameover === undefined || metadata.gameover === null)) {\n      newMetadata = {\n        ...metadata,\n        updatedAt: Date.now()\n      };\n      if (state.ctx.gameover !== undefined) {\n        newMetadata.gameover = state.ctx.gameover;\n      }\n    }\n    if (isSynchronous(this.storageAPI)) {\n      this.storageAPI.setState(key, stateWithoutDeltalog, deltalog);\n      if (newMetadata) this.storageAPI.setMetadata(key, newMetadata);\n    } else {\n      const writes = [this.storageAPI.setState(key, stateWithoutDeltalog, deltalog)];\n      if (newMetadata) {\n        writes.push(this.storageAPI.setMetadata(key, newMetadata));\n      }\n      await Promise.all(writes);\n    }\n  }\n  /**\r\n   * Called when the client connects / reconnects.\r\n   * Returns the latest game state and the entire log.\r\n   */\n  async onSync(matchID, playerID, credentials) {\n    let numPlayers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;\n    const key = matchID;\n    const fetchOpts = {\n      state: true,\n      metadata: true,\n      log: true,\n      initialState: true\n    };\n    const fetchResult = isSynchronous(this.storageAPI) ? this.storageAPI.fetch(key, fetchOpts) : await this.storageAPI.fetch(key, fetchOpts);\n    let {\n      state,\n      initialState,\n      log,\n      metadata\n    } = fetchResult;\n    if (this.auth && playerID !== undefined && playerID !== null) {\n      const isAuthentic = await this.auth.authenticateCredentials({\n        playerID,\n        credentials,\n        metadata\n      });\n      if (!isAuthentic) {\n        return {\n          error: 'unauthorized'\n        };\n      }\n    }\n    // If the game doesn't exist, then create one on demand.\n    // TODO: Move this out of the sync call.\n    if (state === undefined) {\n      const match = createMatch({\n        game: this.game,\n        unlisted: true,\n        numPlayers,\n        setupData: undefined\n      });\n      if ('setupDataError' in match) {\n        return {\n          error: 'game requires setupData'\n        };\n      }\n      initialState = state = match.initialState;\n      metadata = match.metadata;\n      this.subscribeCallback({\n        state,\n        matchID\n      });\n      if (isSynchronous(this.storageAPI)) {\n        this.storageAPI.createMatch(key, {\n          initialState,\n          metadata\n        });\n      } else {\n        await this.storageAPI.createMatch(key, {\n          initialState,\n          metadata\n        });\n      }\n    }\n    const filteredMetadata = metadata ? filterMatchData(metadata) : undefined;\n    const syncInfo = {\n      state,\n      log,\n      filteredMetadata,\n      initialState\n    };\n    this.transportAPI.send({\n      playerID,\n      type: 'sync',\n      args: [matchID, syncInfo]\n    });\n    return;\n  }\n  /**\r\n   * Called when a client connects or disconnects.\r\n   * Updates and sends out metadata to reflect the player’s connection status.\r\n   */\n  async onConnectionChange(matchID, playerID, credentials, connected) {\n    const key = matchID;\n    // Ignore changes for clients without a playerID, e.g. spectators.\n    if (playerID === undefined || playerID === null) {\n      return;\n    }\n    let metadata;\n    if (isSynchronous(this.storageAPI)) {\n      ({\n        metadata\n      } = this.storageAPI.fetch(key, {\n        metadata: true\n      }));\n    } else {\n      ({\n        metadata\n      } = await this.storageAPI.fetch(key, {\n        metadata: true\n      }));\n    }\n    if (metadata === undefined) {\n      error(`metadata not found for matchID=[${key}]`);\n      return {\n        error: 'metadata not found'\n      };\n    }\n    if (metadata.players[playerID] === undefined) {\n      error(`Player not in the match, matchID=[${key}] playerID=[${playerID}]`);\n      return {\n        error: 'player not in the match'\n      };\n    }\n    if (this.auth) {\n      const isAuthentic = await this.auth.authenticateCredentials({\n        playerID,\n        credentials,\n        metadata\n      });\n      if (!isAuthentic) {\n        return {\n          error: 'unauthorized'\n        };\n      }\n    }\n    metadata.players[playerID].isConnected = connected;\n    const filteredMetadata = filterMatchData(metadata);\n    this.transportAPI.sendAll({\n      type: 'matchData',\n      args: [matchID, filteredMetadata]\n    });\n    if (isSynchronous(this.storageAPI)) {\n      this.storageAPI.setMetadata(key, metadata);\n    } else {\n      await this.storageAPI.setMetadata(key, metadata);\n    }\n  }\n  async onChatMessage(matchID, chatMessage, credentials) {\n    const key = matchID;\n    if (this.auth) {\n      const {\n        metadata\n      } = await this.storageAPI.fetch(key, {\n        metadata: true\n      });\n      if (!(chatMessage && typeof chatMessage.sender === 'string')) {\n        return {\n          error: 'unauthorized'\n        };\n      }\n      const isAuthentic = await this.auth.authenticateCredentials({\n        playerID: chatMessage.sender,\n        credentials,\n        metadata\n      });\n      if (!isAuthentic) {\n        return {\n          error: 'unauthorized'\n        };\n      }\n    }\n    this.transportAPI.sendAll({\n      type: 'chat',\n      args: [matchID, chatMessage]\n    });\n  }\n}\nexport { Master as M };","map":{"version":3,"names":["applyMiddleware","createStore","e","error","j","UNDO","R","REDO","M","MAKE_MOVE","P","ProcessGameConfig","C","CreateGameReducer","T","TransientHandlingMiddleware","I","IsLongFormMove","i","isSynchronous","c","createMatch","filterMatchData","matchData","Object","values","players","map","player","credentials","filteredData","stripCredentialsFromAction","action","payload","Master","constructor","game","storageAPI","transportAPI","auth","subscribeCallback","subscribe","fn","onUpdate","credAction","stateID","matchID","playerID","metadata","fetch","isAuthentic","authenticateCredentials","key","state","undefined","ctx","gameover","type","reducer","middleware","store","hasActivePlayers","activePlayers","isCurrentPlayer","currentPlayer","keys","length","flow","isPlayerActive","G","move","getMove","_stateID","ignoreStaleStateID","prevState","getState","dispatch","deltaState","sendAll","args","deltalog","stateWithoutDeltalog","newMetadata","updatedAt","Date","now","setState","setMetadata","writes","push","Promise","all","onSync","numPlayers","arguments","fetchOpts","log","initialState","fetchResult","match","unlisted","setupData","filteredMetadata","syncInfo","send","onConnectionChange","connected","isConnected","onChatMessage","chatMessage","sender"],"sources":["D:/School/488_CMPSC/final_capstone/GUI-based-Web-Game-with-Cloud-Native-Infrastructure-Backend/upwardmobility/node_modules/boardgame.io/dist/esm/master-17425f07.js"],"sourcesContent":["import { applyMiddleware, createStore } from 'redux';\nimport { e as error, j as UNDO, R as REDO, M as MAKE_MOVE } from './turn-order-8cc4909b.js';\nimport { P as ProcessGameConfig, C as CreateGameReducer, T as TransientHandlingMiddleware, I as IsLongFormMove } from './reducer-24ea3e4c.js';\nimport { i as isSynchronous, c as createMatch } from './util-991e76bb.js';\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Filter match data to get a player metadata object with credentials stripped.\r\n */\r\nconst filterMatchData = (matchData) => Object.values(matchData.players).map((player) => {\r\n    const { credentials, ...filteredData } = player;\r\n    return filteredData;\r\n});\r\n/**\r\n * Remove player credentials from action payload\r\n */\r\nconst stripCredentialsFromAction = (action) => {\r\n    const { credentials, ...payload } = action.payload;\r\n    return { ...action, payload };\r\n};\r\n/**\r\n * Master\r\n *\r\n * Class that runs the game and maintains the authoritative state.\r\n * It uses the transportAPI to communicate with clients and the\r\n * storageAPI to communicate with the database.\r\n */\r\nclass Master {\r\n    constructor(game, storageAPI, transportAPI, auth) {\r\n        this.game = ProcessGameConfig(game);\r\n        this.storageAPI = storageAPI;\r\n        this.transportAPI = transportAPI;\r\n        this.subscribeCallback = () => { };\r\n        this.auth = auth;\r\n    }\r\n    subscribe(fn) {\r\n        this.subscribeCallback = fn;\r\n    }\r\n    /**\r\n     * Called on each move / event made by the client.\r\n     * Computes the new value of the game state and returns it\r\n     * along with a deltalog.\r\n     */\r\n    async onUpdate(credAction, stateID, matchID, playerID) {\r\n        if (!credAction || !credAction.payload) {\r\n            return { error: 'missing action or action payload' };\r\n        }\r\n        let metadata;\r\n        if (isSynchronous(this.storageAPI)) {\r\n            ({ metadata } = this.storageAPI.fetch(matchID, { metadata: true }));\r\n        }\r\n        else {\r\n            ({ metadata } = await this.storageAPI.fetch(matchID, { metadata: true }));\r\n        }\r\n        if (this.auth) {\r\n            const isAuthentic = await this.auth.authenticateCredentials({\r\n                playerID,\r\n                credentials: credAction.payload.credentials,\r\n                metadata,\r\n            });\r\n            if (!isAuthentic) {\r\n                return { error: 'unauthorized action' };\r\n            }\r\n        }\r\n        const action = stripCredentialsFromAction(credAction);\r\n        const key = matchID;\r\n        let state;\r\n        if (isSynchronous(this.storageAPI)) {\r\n            ({ state } = this.storageAPI.fetch(key, { state: true }));\r\n        }\r\n        else {\r\n            ({ state } = await this.storageAPI.fetch(key, { state: true }));\r\n        }\r\n        if (state === undefined) {\r\n            error(`game not found, matchID=[${key}]`);\r\n            return { error: 'game not found' };\r\n        }\r\n        if (state.ctx.gameover !== undefined) {\r\n            error(`game over - matchID=[${key}] - playerID=[${playerID}]` +\r\n                ` - action[${action.payload.type}]`);\r\n            return;\r\n        }\r\n        const reducer = CreateGameReducer({\r\n            game: this.game,\r\n        });\r\n        const middleware = applyMiddleware(TransientHandlingMiddleware);\r\n        const store = createStore(reducer, state, middleware);\r\n        // Only allow UNDO / REDO if there is exactly one player\r\n        // that can make moves right now and the person doing the\r\n        // action is that player.\r\n        if (action.type == UNDO || action.type == REDO) {\r\n            const hasActivePlayers = state.ctx.activePlayers !== null;\r\n            const isCurrentPlayer = state.ctx.currentPlayer === playerID;\r\n            if (\r\n            // If activePlayers is empty, non-current players can’t undo.\r\n            (!hasActivePlayers && !isCurrentPlayer) ||\r\n                // If player is not active or multiple players are active, can’t undo.\r\n                (hasActivePlayers &&\r\n                    (state.ctx.activePlayers[playerID] === undefined ||\r\n                        Object.keys(state.ctx.activePlayers).length > 1))) {\r\n                error(`playerID=[${playerID}] cannot undo / redo right now`);\r\n                return;\r\n            }\r\n        }\r\n        // Check whether the player is active.\r\n        if (!this.game.flow.isPlayerActive(state.G, state.ctx, playerID)) {\r\n            error(`player not active - playerID=[${playerID}]` +\r\n                ` - action[${action.payload.type}]`);\r\n            return;\r\n        }\r\n        // Get move for further checks\r\n        const move = action.type == MAKE_MOVE\r\n            ? this.game.flow.getMove(state.ctx, action.payload.type, playerID)\r\n            : null;\r\n        // Check whether the player is allowed to make the move.\r\n        if (action.type == MAKE_MOVE && !move) {\r\n            error(`move not processed - canPlayerMakeMove=false - playerID=[${playerID}]` +\r\n                ` - action[${action.payload.type}]`);\r\n            return;\r\n        }\r\n        // Check if action's stateID is different than store's stateID\r\n        // and if move does not have ignoreStaleStateID truthy.\r\n        if (state._stateID !== stateID &&\r\n            !(move && IsLongFormMove(move) && move.ignoreStaleStateID)) {\r\n            error(`invalid stateID, was=[${stateID}], expected=[${state._stateID}]` +\r\n                ` - playerID=[${playerID}] - action[${action.payload.type}]`);\r\n            return;\r\n        }\r\n        const prevState = store.getState();\r\n        // Update server's version of the store.\r\n        store.dispatch(action);\r\n        state = store.getState();\r\n        this.subscribeCallback({\r\n            state,\r\n            action,\r\n            matchID,\r\n        });\r\n        if (this.game.deltaState) {\r\n            this.transportAPI.sendAll({\r\n                type: 'patch',\r\n                args: [matchID, stateID, prevState, state],\r\n            });\r\n        }\r\n        else {\r\n            this.transportAPI.sendAll({\r\n                type: 'update',\r\n                args: [matchID, state],\r\n            });\r\n        }\r\n        const { deltalog, ...stateWithoutDeltalog } = state;\r\n        let newMetadata;\r\n        if (metadata &&\r\n            (metadata.gameover === undefined || metadata.gameover === null)) {\r\n            newMetadata = {\r\n                ...metadata,\r\n                updatedAt: Date.now(),\r\n            };\r\n            if (state.ctx.gameover !== undefined) {\r\n                newMetadata.gameover = state.ctx.gameover;\r\n            }\r\n        }\r\n        if (isSynchronous(this.storageAPI)) {\r\n            this.storageAPI.setState(key, stateWithoutDeltalog, deltalog);\r\n            if (newMetadata)\r\n                this.storageAPI.setMetadata(key, newMetadata);\r\n        }\r\n        else {\r\n            const writes = [\r\n                this.storageAPI.setState(key, stateWithoutDeltalog, deltalog),\r\n            ];\r\n            if (newMetadata) {\r\n                writes.push(this.storageAPI.setMetadata(key, newMetadata));\r\n            }\r\n            await Promise.all(writes);\r\n        }\r\n    }\r\n    /**\r\n     * Called when the client connects / reconnects.\r\n     * Returns the latest game state and the entire log.\r\n     */\r\n    async onSync(matchID, playerID, credentials, numPlayers = 2) {\r\n        const key = matchID;\r\n        const fetchOpts = {\r\n            state: true,\r\n            metadata: true,\r\n            log: true,\r\n            initialState: true,\r\n        };\r\n        const fetchResult = isSynchronous(this.storageAPI)\r\n            ? this.storageAPI.fetch(key, fetchOpts)\r\n            : await this.storageAPI.fetch(key, fetchOpts);\r\n        let { state, initialState, log, metadata } = fetchResult;\r\n        if (this.auth && playerID !== undefined && playerID !== null) {\r\n            const isAuthentic = await this.auth.authenticateCredentials({\r\n                playerID,\r\n                credentials,\r\n                metadata,\r\n            });\r\n            if (!isAuthentic) {\r\n                return { error: 'unauthorized' };\r\n            }\r\n        }\r\n        // If the game doesn't exist, then create one on demand.\r\n        // TODO: Move this out of the sync call.\r\n        if (state === undefined) {\r\n            const match = createMatch({\r\n                game: this.game,\r\n                unlisted: true,\r\n                numPlayers,\r\n                setupData: undefined,\r\n            });\r\n            if ('setupDataError' in match) {\r\n                return { error: 'game requires setupData' };\r\n            }\r\n            initialState = state = match.initialState;\r\n            metadata = match.metadata;\r\n            this.subscribeCallback({ state, matchID });\r\n            if (isSynchronous(this.storageAPI)) {\r\n                this.storageAPI.createMatch(key, { initialState, metadata });\r\n            }\r\n            else {\r\n                await this.storageAPI.createMatch(key, { initialState, metadata });\r\n            }\r\n        }\r\n        const filteredMetadata = metadata ? filterMatchData(metadata) : undefined;\r\n        const syncInfo = {\r\n            state,\r\n            log,\r\n            filteredMetadata,\r\n            initialState,\r\n        };\r\n        this.transportAPI.send({\r\n            playerID,\r\n            type: 'sync',\r\n            args: [matchID, syncInfo],\r\n        });\r\n        return;\r\n    }\r\n    /**\r\n     * Called when a client connects or disconnects.\r\n     * Updates and sends out metadata to reflect the player’s connection status.\r\n     */\r\n    async onConnectionChange(matchID, playerID, credentials, connected) {\r\n        const key = matchID;\r\n        // Ignore changes for clients without a playerID, e.g. spectators.\r\n        if (playerID === undefined || playerID === null) {\r\n            return;\r\n        }\r\n        let metadata;\r\n        if (isSynchronous(this.storageAPI)) {\r\n            ({ metadata } = this.storageAPI.fetch(key, { metadata: true }));\r\n        }\r\n        else {\r\n            ({ metadata } = await this.storageAPI.fetch(key, { metadata: true }));\r\n        }\r\n        if (metadata === undefined) {\r\n            error(`metadata not found for matchID=[${key}]`);\r\n            return { error: 'metadata not found' };\r\n        }\r\n        if (metadata.players[playerID] === undefined) {\r\n            error(`Player not in the match, matchID=[${key}] playerID=[${playerID}]`);\r\n            return { error: 'player not in the match' };\r\n        }\r\n        if (this.auth) {\r\n            const isAuthentic = await this.auth.authenticateCredentials({\r\n                playerID,\r\n                credentials,\r\n                metadata,\r\n            });\r\n            if (!isAuthentic) {\r\n                return { error: 'unauthorized' };\r\n            }\r\n        }\r\n        metadata.players[playerID].isConnected = connected;\r\n        const filteredMetadata = filterMatchData(metadata);\r\n        this.transportAPI.sendAll({\r\n            type: 'matchData',\r\n            args: [matchID, filteredMetadata],\r\n        });\r\n        if (isSynchronous(this.storageAPI)) {\r\n            this.storageAPI.setMetadata(key, metadata);\r\n        }\r\n        else {\r\n            await this.storageAPI.setMetadata(key, metadata);\r\n        }\r\n    }\r\n    async onChatMessage(matchID, chatMessage, credentials) {\r\n        const key = matchID;\r\n        if (this.auth) {\r\n            const { metadata } = await this.storageAPI.fetch(key, {\r\n                metadata: true,\r\n            });\r\n            if (!(chatMessage && typeof chatMessage.sender === 'string')) {\r\n                return { error: 'unauthorized' };\r\n            }\r\n            const isAuthentic = await this.auth.authenticateCredentials({\r\n                playerID: chatMessage.sender,\r\n                credentials,\r\n                metadata,\r\n            });\r\n            if (!isAuthentic) {\r\n                return { error: 'unauthorized' };\r\n            }\r\n        }\r\n        this.transportAPI.sendAll({\r\n            type: 'chat',\r\n            args: [matchID, chatMessage],\r\n        });\r\n    }\r\n}\n\nexport { Master as M };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}